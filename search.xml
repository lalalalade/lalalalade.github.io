<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划</title>
    <url>/2020/12/29/DP/</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>问题的最优解如果可以由<strong>子问题</strong>的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题有较多的<strong>重复出现</strong>，则可以自底向上从最终子问题向原问题逐步求解。</p>
<a id="more"></a>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>可分为多个相关子问题，子问题的解被<strong>重复</strong>使用。</p>
<h4 id="Optimal-substructure（优化子结构）"><a href="#Optimal-substructure（优化子结构）" class="headerlink" title="Optimal substructure（优化子结构）"></a>Optimal substructure（优化子结构）</h4><p>一个问题的优化解包含了子问题的优化解<br>缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性<br>我们可以自下而上的</p>
<h4 id="Subteties（重叠子问题）"><a href="#Subteties（重叠子问题）" class="headerlink" title="Subteties（重叠子问题）"></a>Subteties（重叠子问题）</h4><p>在问题的求解过程中，很多子问题的解将被多次使用。</p>
<h3 id="动态规划算法的设计步骤："><a href="#动态规划算法的设计步骤：" class="headerlink" title="动态规划算法的设计步骤："></a>动态规划算法的设计步骤：</h3><p>分析优化解的结构<br>递归地定义最优解的代价<br>自底向上地计算优化解的代价保存之，并获取构造最优解的信息<br>根据构造最优解的信息构造优化解</p>
<h3 id="动态规划特点："><a href="#动态规划特点：" class="headerlink" title="动态规划特点："></a>动态规划特点：</h3><p>把原始问题划分成一系列子问题；<br>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间<br>自底向上地计算。<br>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）</p>
<hr>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p>递归法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maxSum[i][j] != <span class="number">-1</span>)&#123;   <span class="comment">//表示已经计算过这个值了，可以直接取 不用重复计算</span></span><br><span class="line">		<span class="keyword">return</span> maxSum[i][j];</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">if</span>(i == n)&#123;     <span class="comment">//最后一行 </span></span><br><span class="line">		maxSum[i][j] = D[i][j];</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = MaxSum(i+<span class="number">1</span>,j);</span><br><span class="line">		<span class="keyword">int</span> y = MaxSum(i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">		maxSum[i][j] = max(x,y)+D[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;D[i][j];</span><br><span class="line">			maxSum[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>递推法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;   <span class="comment">//初始化最后一行 </span></span><br><span class="line">	maxSum[n][i] = D[n][i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">		maxSum[i][j] = max(maxSum[i+<span class="number">1</span>][j],maxSum[i+<span class="number">1</span>][j+<span class="number">1</span>]) + D[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>递归法是<strong>自顶向下</strong>，而动态规划(递推法)是<strong>自底向上</strong>。对于递推法我们还可以进行<strong>空间优化</strong>，将maxSum数组改造为一维数组，再优化，maxSum = D[n],即用D数组最后一行存放结果。</p>
<hr>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>有N种物品，每种只有一个。第i中物品的体积为Vi，重量为Wi,选择一些物品装到一个容量为C的背包，使得背包内的物品再总体积不超过M的前提下重量尽量大，1&lt;=N&lt;=100,1&lt;=Vi&lt;=C&lt;=10000,1&lt;=Wi&lt;=1000000。<br>思路：<br>用dp[i][j]表示取前i种物品，使它们总体积不超过j的最优取法取得的价值总和。要求dp[N][C]。<br>递推：dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+w[i]),前提j&gt;=w,取或不取第i种物品，两者选优。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N+<span class="number">1</span>][C+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//填表</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=C; j++)&#123; <span class="comment">//j的所有取值范围 </span></span><br><span class="line">		<span class="keyword">if</span>(j&lt;v[i])&#123; <span class="comment">//可装体积小于第i件物品的体积 </span></span><br><span class="line">			dp[i][j] = dp[i<span class="number">-1</span>][j]; <span class="comment">//不装第i件物品 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;  <span class="comment">//考虑装不装第i件物品 </span></span><br><span class="line">			<span class="keyword">int</span> x = dp[i<span class="number">-1</span>][j];  <span class="comment">//不装第i件物品 </span></span><br><span class="line">			<span class="keyword">int</span> y = dp[i<span class="number">-1</span>][j-w[i]] + w[i];  <span class="comment">//装第i件物品 </span></span><br><span class="line">			dp[i][j] = x&lt;y ? y : x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用滚动数组优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[C+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=C; j&gt;=<span class="number">1</span>; j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">				dp[j] = max(dp[j],dp[j-w[i]] + w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2020/12/28/HeapSort/</url>
    <content><![CDATA[<h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p>堆（Heap）可以定义为一棵<strong>二叉树</strong>，树的节点中包含键（每个节点一个键），并且满足以下两个条件：（1）这棵二叉树是基本完备的（或者称为<strong>完全二叉树</strong>）（2）<strong>父母优势</strong>，即每个节点的键都要大于或等于它子女的键。<br>堆排序的时间复杂度为O(nlog n)</p>
<a id="more"></a>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>函数Heapity(int arr[ ], int start, int end)负责构造一个堆，其中start和end参数指明数组的起始和终止位置。<br>函数HeapSort(int arr[ ], int len)负责实现堆排序。<br>函数的具体实现代码见下。</p>
<h3 id="Heapity函数"><a href="#Heapity函数" class="headerlink" title="Heapity函数"></a>Heapity函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapity</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dad = start; <span class="comment">//父节点位置</span></span><br><span class="line">	<span class="keyword">int</span> son = <span class="number">2</span>*start; <span class="comment">//第一个子节点位置</span></span><br><span class="line">	<span class="keyword">while</span>(son &lt;= end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(son+<span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son+<span class="number">1</span>])&#123; <span class="comment">//左子节点小于右子节点</span></span><br><span class="line">			son+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(arr[dad] &gt; arr[son])&#123;   <span class="comment">//满足父母优势</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(&amp;arr[dad],&amp;arr[son]); <span class="comment">//交换父节点和较大子节点的数值</span></span><br><span class="line">			dad = son;</span><br><span class="line">			son = <span class="number">2</span>*dad;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HeapSort函数"><a href="#HeapSort函数" class="headerlink" title="HeapSort函数"></a>HeapSort函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;  </span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span>  i=len/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)&#123;  <span class="comment">//从最后一个父节点开始，一直到根</span></span><br><span class="line">		Heapity(arr,i,len);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len; i&gt;<span class="number">0</span>; i--)&#123;  <span class="comment">//每次对根节点构建堆，将最大值与最后一位数交换</span></span><br><span class="line">		swap(&amp;arr[<span class="number">1</span>],&amp;arr[i]);  <span class="comment">//交换各个堆的最大值和最后一位的值</span></span><br><span class="line">		Heapity(arr,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/27/MergeSort/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是基于<strong>分治法</strong>的一种算法。对于一个需要排序的数组A[0,…,n-1]; 归并排序把它<strong>一分为二</strong>，并对每个子数组递归排序，然后再把这两个排好序的数组合并成一个有序数组。其中tmp数组用于临时存放合并时产生的有顺序的数，最后赋值给需要排序的原数组A。</p>
<a id="more"></a>
<p>下面是<strong>合并两个有序子数组</strong>（默认从小到大）的函数<strong>Merge</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m, <span class="keyword">int</span> r, <span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pb = <span class="number">0</span>;               <span class="comment">//pb用于按顺序将数字填入tmp数组</span></span><br><span class="line">	<span class="keyword">int</span> p1 = l,p2 = m+<span class="number">1</span>;      <span class="comment">//p1,p2分别是两个子数组开始下标</span></span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;   <span class="comment">//两个子数组中的数都没有遍历完</span></span><br><span class="line">		<span class="keyword">if</span>(a[p1] &lt; a[p2])&#123;</span><br><span class="line">			tmp[pb++] = a[p1++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[pb++] = a[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m)&#123;        <span class="comment">//p2数组遍历完成，剩下p1数组中的数字都大于p2数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p1++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p2 &lt;= r)&#123;        <span class="comment">//p1数组遍历完成，剩下p2数组中的数字都大于p1数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p2++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r-l+<span class="number">1</span>; i++)&#123;   <span class="comment">//赋值回原数组，实现了两个有序数组的合并</span></span><br><span class="line">		a[l+i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用于实现<strong>递归调用来排序</strong>的函数<strong>MergeSort</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">		MergeSort(a,l,m,tmp);  <span class="comment">//对左半部分归并排序 </span></span><br><span class="line">		MergeSort(a,m+<span class="number">1</span>,r,tmp); <span class="comment">//对右半部分归并排序 </span></span><br><span class="line">		Merge(a,l,m,r,tmp);   <span class="comment">//合并两部分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>归并排序在最坏的情况下的键值比较次数十分接近于基于排序算法在理论上能够达到的<strong>最少次数</strong>。平均情况下时间复杂度属于<strong>O(nlog n)</strong>,相比于快速排序和堆排序，它具有<strong>稳定性</strong>。缺点在于需要线性的额外空间，因此只具有理论意义。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/28/QuickSort/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是另一种基于<strong>分治法</strong>的排序算法，不像归并排序按照元素在数组中的位置对它们进行划分，快速排序按照元素的<strong>值</strong>对它们进行划分。<strong>划分</strong>：对给定数组中的元素重新排列，使得A[s]左边的元素都小于等于A[s],右边的元素都大于等于A[s]。算法的主要工作在划分阶段，而不需要再去合并子问题的解。以下介绍两种划分方法：<strong>Lomuto划分</strong>和<strong>Hoare划分</strong>。</p>
<a id="more"></a>
<h3 id="Lomuto划分"><a href="#Lomuto划分" class="headerlink" title="Lomuto划分"></a>Lomuto划分</h3><p>Lomuto划分原理：先设置一个中轴作为基准（一般是数组第一个），设置两个整型变量i和s，算法从左到右扫描数组，若A[i] &gt;= p, i递增即<strong>扩大了</strong>大于p的段，若A[i] &lt; p，则小于p的段需要扩大，这通过<strong>s递增</strong>实现：s指向第一段的最后一个元素，s+=1，再交换A[i]和A[s]，然后i递增，直至全部处理完毕。处理完毕之后，再交换A[s]和p。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lomuto</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = left;</span><br><span class="line">	<span class="keyword">int</span> temp = data[left];                   <span class="comment">//把尾数看做基准数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;right; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(data[i] &lt; temp)&#123;</span><br><span class="line">            s += <span class="number">1</span>;</span><br><span class="line">			swap(data[i],data[s]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(data[s],data[left]);</span><br><span class="line">	<span class="keyword">return</span> s;                         <span class="comment">//返回基准数的位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">int</span> i = Lomuto(left,right);   <span class="comment">//划分 </span></span><br><span class="line">		quickSort(left,i<span class="number">-1</span>);             <span class="comment">//分治：i左边的继续划分 </span></span><br><span class="line">		quickSort(i+<span class="number">1</span>,right);            <span class="comment">//分治：i右边的继续划分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hoare划分"><a href="#Hoare划分" class="headerlink" title="Hoare划分"></a>Hoare划分</h3><p>Hoare划分原理：定义两个整型变量i,j分别从数组两端同时开始扫描，i会忽略小于中轴的数，遇到第一个大于等于中轴的数时停止，相应j会忽略大于中轴的数，遇到第一个小于等于中轴的数时停止。此时会有三种情况：<br>1：i和j未相交，即i小于j，那么<strong>交换</strong>A[i]和A[j]的值，对i加一，对j减一，继续扫描。<br>2：i等于j，说明这时i和j都指向了中轴，划分完毕。<br>3：i和j相交，即i大于j，那么交换中轴和A[j]，划分完毕。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hoare</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span>  right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = A[left];   <span class="comment">//设置中轴</span></span><br><span class="line">	<span class="keyword">int</span> i = left+<span class="number">1</span>, j = right;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123; <span class="comment">//只要i&lt;j就还要进行扫描,直到i&gt;=j为止</span></span><br><span class="line">		<span class="keyword">while</span>(A[i]&lt;p)&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;             <span class="comment">//使i停在第一个大于等于p的位置上</span></span><br><span class="line">		<span class="keyword">while</span>(A[j]&gt;p)&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;            <span class="comment">//使j停在第一个小于等于p的位置上</span></span><br><span class="line">		swap(A[i],A[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i],A[j]);     <span class="comment">//当i&gt;=j时撤销最后一次交换 </span></span><br><span class="line">	swap(A[left],A[j]);  <span class="comment">//交换中轴和A[j]</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		QuickSort(left,Hoare(left,right)<span class="number">-1</span>);</span><br><span class="line">		QuickSort(Hoare(left,right)+<span class="number">1</span>,right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管快速排序的平均时间复杂度为O(nlog n)，它是不稳定的，存在最坏情况下时间复杂度为O(n2)的可能。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序和冒泡排序</title>
    <url>/2020/12/28/SelectionSort/</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序属于<strong>蛮力法</strong>，开始的时候，扫描整个列表，找到它的<strong>最小元素</strong>，然后和<strong>第一个元素</strong>交换，将最小元素放在它最终位置上。然后从第二个元素扫描数组，找到后n-1个元素中的最小元素，和第二个元素交换，n-1遍以后排好序。键的<strong>交换次数</strong>仅为O(n),时间复杂度为O(n2)。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SelectionSort(<span class="keyword">int</span> a[])&#123;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;a[i],&amp;a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序<strong>比较相邻元素</strong>，如果它们逆序的话交换它们的位置。重复多次以后，最大的元素沉到最底部。第二遍让第二大元素沉下去。直到n-1遍以后，排序完成。键的交换次数<strong>取决于</strong>输入的数，最坏和平均时间复杂度为O(n2)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BubbleSort(<span class="keyword">int</span> a[])&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j+<span class="number">1</span>] &lt; a[j])&#123;</span><br><span class="line">                swap(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/12/29/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>把整个问题分成多个步骤，在每个步骤都选取<strong>当前步骤</strong>的最优方案，直到所有步骤结束<br>在每一步都不考虑对后续步骤的影响，在后续的步骤中也不改变前面的选择。所以这是局部最优，<strong>不一定</strong>达到整体最优。</p>
<a id="more"></a>
<h3 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h3><p>问题描述：某人带着1元，2元，5元三种面值的硬币去购物，硬币的数量不限，他需要支付M元，问怎样支付才能使硬币数量最少？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,money;</span><br><span class="line">	<span class="keyword">int</span> ans[NUM] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录各种硬币的数量</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;money;</span><br><span class="line">	<span class="keyword">for</span>(i=NUM<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		ans[i] = money/value[i];</span><br><span class="line">		money -= ans[i] * value[i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM; i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;value[i]&lt;&lt;<span class="string">&quot;元硬币数&quot;</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-贪心</tag>
      </tags>
  </entry>
</search>
