<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/28/QuickSort/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是另一种基于<strong>分治法</strong>的排序算法，不像归并排序按照元素在数组中的位置对它们进行划分，快速排序按照元素的<strong>值</strong>对它们进行划分。<strong>划分</strong>：对给定数组中的元素重新排列，使得A[s]左边的元素都小于等于A[s],右边的元素都大于等于A[s]。算法的主要工作在划分阶段，而不需要再去合并子问题的解。以下介绍两种划分方法：<strong>Lomuto划分</strong>和<strong>Hoare划分</strong>。</p>
<a id="more"></a>
<h3 id="Lomuto划分"><a href="#Lomuto划分" class="headerlink" title="Lomuto划分"></a>Lomuto划分</h3><p>Lomuto划分原理：先设置一个中轴作为基准（一般是数组第一个），设置两个整型变量i和s，算法从左到右扫描数组，若A[i] &gt;= p, i递增即<strong>扩大了</strong>大于p的段，若A[i] &lt; p，则小于p的段需要扩大，这通过<strong>s递增</strong>实现：s指向第一段的最后一个元素，s+=1，再交换A[i]和A[s]，然后i递增，直至全部处理完毕。处理完毕之后，再交换A[s]和p。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lomuto</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = left;</span><br><span class="line">	<span class="keyword">int</span> temp = data[left];                   <span class="comment">//把尾数看做基准数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;right; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(data[i] &lt; temp)&#123;</span><br><span class="line">            s += <span class="number">1</span>;</span><br><span class="line">			swap(data[i],data[s]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(data[s],data[left]);</span><br><span class="line">	<span class="keyword">return</span> s;                         <span class="comment">//返回基准数的位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">int</span> i = Lomuto(left,right);   <span class="comment">//划分 </span></span><br><span class="line">		quickSort(left,i<span class="number">-1</span>);             <span class="comment">//分治：i左边的继续划分 </span></span><br><span class="line">		quickSort(i+<span class="number">1</span>,right);            <span class="comment">//分治：i右边的继续划分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hoare划分"><a href="#Hoare划分" class="headerlink" title="Hoare划分"></a>Hoare划分</h3><p>Hoare划分原理：定义两个整型变量i,j分别从数组两端同时开始扫描，i会忽略小于中轴的数，遇到第一个大于等于中轴的数时停止，相应j会忽略大于中轴的数，遇到第一个小于等于中轴的数时停止。此时会有三种情况：<br>1：i和j未相交，即i小于j，那么<strong>交换</strong>A[i]和A[j]的值，对i加一，对j减一，继续扫描。<br>2：i等于j，说明这时i和j都指向了中轴，划分完毕。<br>3：i和j相交，即i大于j，那么交换中轴和A[j]，划分完毕。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hoare</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span>  right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = A[left];   <span class="comment">//设置中轴</span></span><br><span class="line">	<span class="keyword">int</span> i = left+<span class="number">1</span>, j = right;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123; <span class="comment">//只要i&lt;j就还要进行扫描,直到i&gt;=j为止</span></span><br><span class="line">		<span class="keyword">while</span>(A[i]&lt;p)&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;             <span class="comment">//使i停在第一个大于等于p的位置上</span></span><br><span class="line">		<span class="keyword">while</span>(A[j]&gt;p)&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;            <span class="comment">//使j停在第一个小于等于p的位置上</span></span><br><span class="line">		swap(A[i],A[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i],A[j]);     <span class="comment">//当i&gt;=j时撤销最后一次交换 </span></span><br><span class="line">	swap(A[left],A[j]);  <span class="comment">//交换中轴和A[j]</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		QuickSort(left,Hoare(left,right)<span class="number">-1</span>);</span><br><span class="line">		QuickSort(Hoare(left,right)+<span class="number">1</span>,right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管快速排序的平均时间复杂度为O(nlog n)，它是不稳定的，存在最坏情况下时间复杂度为O(n2)的可能。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2020/12/28/HeapSort/</url>
    <content><![CDATA[<h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p>堆（Heap）可以定义为一棵<strong>二叉树</strong>，树的节点中包含键（每个节点一个键），并且满足以下两个条件：（1）这棵二叉树是基本完备的（或者称为<strong>完全二叉树</strong>）（2）<strong>父母优势</strong>，即每个节点的键都要大于或等于它子女的键。<br>堆排序的时间复杂度为O(nlog n)</p>
<a id="more"></a>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>函数Heapity(int arr[ ], int start, int end)负责构造一个堆，其中start和end参数指明数组的起始和终止位置。<br>函数HeapSort(int arr[ ], int len)负责实现堆排序。<br>函数的具体实现代码见下。</p>
<h3 id="Heapity函数"><a href="#Heapity函数" class="headerlink" title="Heapity函数"></a>Heapity函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapity</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dad = start; <span class="comment">//父节点位置</span></span><br><span class="line">	<span class="keyword">int</span> son = <span class="number">2</span>*start; <span class="comment">//第一个子节点位置</span></span><br><span class="line">	<span class="keyword">while</span>(son &lt;= end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(son+<span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son+<span class="number">1</span>])&#123; <span class="comment">//左子节点小于右子节点</span></span><br><span class="line">			son+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(arr[dad] &gt; arr[son])&#123;   <span class="comment">//满足父母优势</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(&amp;arr[dad],&amp;arr[son]); <span class="comment">//交换父节点和较大子节点的数值</span></span><br><span class="line">			dad = son;</span><br><span class="line">			son = <span class="number">2</span>*dad;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HeapSort函数"><a href="#HeapSort函数" class="headerlink" title="HeapSort函数"></a>HeapSort函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;  </span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span>  i=len/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)&#123;  <span class="comment">//从最后一个父节点开始，一直到根</span></span><br><span class="line">		Heapity(arr,i,len);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len; i&gt;<span class="number">0</span>; i--)&#123;  <span class="comment">//每次对根节点构建堆，将最大值与最后一位数交换</span></span><br><span class="line">		swap(&amp;arr[<span class="number">1</span>],&amp;arr[i]);  <span class="comment">//交换各个堆的最大值和最后一位的值</span></span><br><span class="line">		Heapity(arr,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/27/MergeSort/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是基于<strong>分治法</strong>的一种算法。对于一个需要排序的数组A[0,…,n-1]; 归并排序把它<strong>一分为二</strong>，并对每个子数组递归排序，然后再把这两个排好序的数组合并成一个有序数组。其中tmp数组用于临时存放合并时产生的有顺序的数，最后赋值给需要排序的原数组A。</p>
<a id="more"></a>
<p>下面是<strong>合并两个有序子数组</strong>（默认从小到大）的函数<strong>Merge</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m, <span class="keyword">int</span> r, <span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pb = <span class="number">0</span>;               <span class="comment">//pb用于按顺序将数字填入tmp数组</span></span><br><span class="line">	<span class="keyword">int</span> p1 = l,p2 = m+<span class="number">1</span>;      <span class="comment">//p1,p2分别是两个子数组开始下标</span></span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;   <span class="comment">//两个子数组中的数都没有遍历完</span></span><br><span class="line">		<span class="keyword">if</span>(a[p1] &lt; a[p2])&#123;</span><br><span class="line">			tmp[pb++] = a[p1++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[pb++] = a[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m)&#123;        <span class="comment">//p2数组遍历完成，剩下p1数组中的数字都大于p2数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p1++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p2 &lt;= r)&#123;        <span class="comment">//p1数组遍历完成，剩下p2数组中的数字都大于p1数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p2++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r-l+<span class="number">1</span>; i++)&#123;   <span class="comment">//赋值回原数组，实现了两个有序数组的合并</span></span><br><span class="line">		a[l+i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用于实现<strong>递归调用来排序</strong>的函数<strong>MergeSort</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">		MergeSort(a,l,m,tmp);  <span class="comment">//对左半部分归并排序 </span></span><br><span class="line">		MergeSort(a,m+<span class="number">1</span>,r,tmp); <span class="comment">//对右半部分归并排序 </span></span><br><span class="line">		Merge(a,l,m,r,tmp);   <span class="comment">//合并两部分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>归并排序在最坏的情况下的键值比较次数十分接近于基于排序算法在理论上能够达到的<strong>最少次数</strong>。平均情况下时间复杂度属于<strong>O(nlog n)</strong>,相比于快速排序和堆排序，它具有<strong>稳定性</strong>。缺点在于需要线性的额外空间，因此只具有理论意义。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序和冒泡排序</title>
    <url>/2020/12/28/SelectionSort/</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序属于<strong>蛮力法</strong>，开始的时候，扫描整个列表，找到它的<strong>最小元素</strong>，然后和<strong>第一个元素</strong>交换，将最小元素放在它最终位置上。然后从第二个元素扫描数组，找到后n-1个元素中的最小元素，和第二个元素交换，n-1遍以后排好序。键的<strong>交换次数</strong>仅为O(n),时间复杂度为O(n2)。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SelectionSort(<span class="keyword">int</span> a[])&#123;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;a[i],&amp;a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序<strong>比较相邻元素</strong>，如果它们逆序的话交换它们的位置。重复多次以后，最大的元素沉到最底部。第二遍让第二大元素沉下去。直到n-1遍以后，排序完成。键的交换次数<strong>取决于</strong>输入的数，最坏和平均时间复杂度为O(n2)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BubbleSort(<span class="keyword">int</span> a[])&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j+<span class="number">1</span>] &lt; a[j])&#123;</span><br><span class="line">                swap(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
