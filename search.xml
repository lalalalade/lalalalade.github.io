<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/27/MergeSort/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是基于<strong>分治法</strong>的一种算法。对于一个需要排序的数组A[0,…,n-1]; 归并排序把它<strong>一分为二</strong>，并对每个子数组递归排序，然后再把这两个排好序的数组合并成一个有序数组。其中tmp数组用于临时存放合并时产生的有顺序的数，最后赋值给需要排序的原数组A。</p>
<a id="more"></a>
<p>下面是<strong>合并两个有序子数组</strong>（默认从小到大）的函数<strong>Merge</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m, <span class="keyword">int</span> r, <span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pb = <span class="number">0</span>;               <span class="comment">//pb用于按顺序将数字填入tmp数组</span></span><br><span class="line">	<span class="keyword">int</span> p1 = l,p2 = m+<span class="number">1</span>;      <span class="comment">//p1,p2分别是两个子数组开始下标</span></span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;   <span class="comment">//两个子数组中的数都没有遍历完</span></span><br><span class="line">		<span class="keyword">if</span>(a[p1] &lt; a[p2])&#123;</span><br><span class="line">			tmp[pb++] = a[p1++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[pb++] = a[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m)&#123;        <span class="comment">//p2数组遍历完成，剩下p1数组中的数字都大于p2数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p1++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p2 &lt;= r)&#123;        <span class="comment">//p1数组遍历完成，剩下p2数组中的数字都大于p1数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p2++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r-l+<span class="number">1</span>; i++)&#123;   <span class="comment">//赋值回原数组，实现了两个有序数组的合并</span></span><br><span class="line">		a[l+i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用于实现<strong>递归调用来排序</strong>的函数<strong>MergeSort</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">		MergeSort(a,l,m,tmp);  <span class="comment">//对左半部分归并排序 </span></span><br><span class="line">		MergeSort(a,m+<span class="number">1</span>,r,tmp); <span class="comment">//对右半部分归并排序 </span></span><br><span class="line">		Merge(a,l,m,r,tmp);   <span class="comment">//合并两部分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：归并排序在最坏的情况下的键值比较次数十分接近于基于排序算法在理论上能够达到的<strong>最少次数</strong>。平均情况下时间复杂度属于<strong>O(nlog n)</strong>,相比于快速排序和堆排序，它具有<strong>稳定性</strong>。缺点在于需要线性的额外空间，因此只具有理论意义。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
