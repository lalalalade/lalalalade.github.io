<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/27/MergeSort/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是基于<strong>分治法</strong>的一种算法。对于一个需要排序的数组A[0,…,n-1]; 归并排序把它<strong>一分为二</strong>，并对每个子数组递归排序，然后再把这两个排好序的数组合并成一个有序数组。其中tmp数组用于临时存放合并时产生的有顺序的数，最后赋值给需要排序的原数组A。</p>
<a id="more"></a>
<p>下面是<strong>合并两个有序子数组</strong>（默认从小到大）的函数<strong>Merge</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m, <span class="keyword">int</span> r, <span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pb = <span class="number">0</span>;               <span class="comment">//pb用于按顺序将数字填入tmp数组</span></span><br><span class="line">	<span class="keyword">int</span> p1 = l,p2 = m+<span class="number">1</span>;      <span class="comment">//p1,p2分别是两个子数组开始下标</span></span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;   <span class="comment">//两个子数组中的数都没有遍历完</span></span><br><span class="line">		<span class="keyword">if</span>(a[p1] &lt; a[p2])&#123;</span><br><span class="line">			tmp[pb++] = a[p1++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[pb++] = a[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt;= m)&#123;        <span class="comment">//p2数组遍历完成，剩下p1数组中的数字都大于p2数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p1++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p2 &lt;= r)&#123;        <span class="comment">//p1数组遍历完成，剩下p2数组中的数字都大于p1数组中的数</span></span><br><span class="line">		tmp[pb++] = a[p2++];   <span class="comment">//添加到末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r-l+<span class="number">1</span>; i++)&#123;   <span class="comment">//赋值回原数组，实现了两个有序数组的合并</span></span><br><span class="line">		a[l+i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用于实现<strong>递归调用来排序</strong>的函数<strong>MergeSort</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">		MergeSort(a,l,m,tmp);  <span class="comment">//对左半部分归并排序 </span></span><br><span class="line">		MergeSort(a,m+<span class="number">1</span>,r,tmp); <span class="comment">//对右半部分归并排序 </span></span><br><span class="line">		Merge(a,l,m,r,tmp);   <span class="comment">//合并两部分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>归并排序在最坏的情况下的键值比较次数十分接近于基于排序算法在理论上能够达到的<strong>最少次数</strong>。平均情况下时间复杂度属于<strong>O(nlog n)</strong>,相比于快速排序和堆排序，它具有<strong>稳定性</strong>。缺点在于需要线性的额外空间，因此只具有理论意义。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/28/QuickSort/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是另一种基于<strong>分治法</strong>的排序算法，不像归并排序按照元素在数组中的位置对它们进行划分，快速排序按照元素的<strong>值</strong>对它们进行划分。<strong>划分</strong>：对给定数组中的元素重新排列，使得A[s]左边的元素都小于等于A[s],右边的元素都大于等于A[s]。算法的主要工作在划分阶段，而不需要再去合并子问题的解。以下介绍两种划分方法：<strong>Lomuto划分</strong>和<strong>Hoare划分</strong>。</p>
<a id="more"></a>
<h3 id="Lomuto划分"><a href="#Lomuto划分" class="headerlink" title="Lomuto划分"></a>Lomuto划分</h3><p>Lomuto划分原理：先设置一个中轴作为基准（一般是数组第一个），设置两个整型变量i和s，算法从左到右扫描数组，若A[i] &gt;= p, i递增即<strong>扩大了</strong>大于p的段，若A[i] &lt; p，则小于p的段需要扩大，这通过<strong>s递增</strong>实现：s指向第一段的最后一个元素，s+=1，再交换A[i]和A[s]，然后i递增，直至全部处理完毕。处理完毕之后，再交换A[s]和p。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lomuto</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = left;</span><br><span class="line">	<span class="keyword">int</span> temp = data[left];                   <span class="comment">//把尾数看做基准数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;right; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(data[i] &lt; temp)&#123;</span><br><span class="line">            s += <span class="number">1</span>;</span><br><span class="line">			swap(data[i],data[s]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(data[s],data[left]);</span><br><span class="line">	<span class="keyword">return</span> s;                         <span class="comment">//返回基准数的位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">int</span> i = Lomuto(left,right);   <span class="comment">//划分 </span></span><br><span class="line">		quickSort(left,i<span class="number">-1</span>);             <span class="comment">//分治：i左边的继续划分 </span></span><br><span class="line">		quickSort(i+<span class="number">1</span>,right);            <span class="comment">//分治：i右边的继续划分 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hoare划分"><a href="#Hoare划分" class="headerlink" title="Hoare划分"></a>Hoare划分</h3><p>Hoare划分原理：定义两个整型变量i,j分别从数组两端同时开始扫描，i会忽略小于中轴的数，遇到第一个大于等于中轴的数时停止，相应j会忽略大于中轴的数，遇到第一个小于等于中轴的数时停止。此时会有三种情况：<br>1：i和j未相交，即i小于j，那么<strong>交换</strong>A[i]和A[j]的值，对i加一，对j减一，继续扫描。<br>2：i等于j，说明这时i和j都指向了中轴，划分完毕。<br>3：i和j相交，即i大于j，那么交换中轴和A[j]，划分完毕。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hoare</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span>  right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = A[left];   <span class="comment">//设置中轴</span></span><br><span class="line">	<span class="keyword">int</span> i = left+<span class="number">1</span>, j = right;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123; <span class="comment">//只要i&lt;j就还要进行扫描,直到i&gt;=j为止</span></span><br><span class="line">		<span class="keyword">while</span>(A[i]&lt;p)&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;             <span class="comment">//使i停在第一个大于等于p的位置上</span></span><br><span class="line">		<span class="keyword">while</span>(A[j]&gt;p)&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;            <span class="comment">//使j停在第一个小于等于p的位置上</span></span><br><span class="line">		swap(A[i],A[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i],A[j]);     <span class="comment">//当i&gt;=j时撤销最后一次交换 </span></span><br><span class="line">	swap(A[left],A[j]);  <span class="comment">//交换中轴和A[j]</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		QuickSort(left,Hoare(left,right)<span class="number">-1</span>);</span><br><span class="line">		QuickSort(Hoare(left,right)+<span class="number">1</span>,right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管快速排序的平均时间复杂度为O(nlog n)，它是不稳定的，存在最坏情况下时间复杂度为O(n2)的可能。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
